## Java 多线程编程实战指南（设计模式篇）

Java中的线程可分为**守护线程(Daemon Thread)**和**用户线程(User Thread)**。用户线程阻止JVM的正常停止，即JVM正常停止前应用程序中的所有用户线程必须先停止完毕；否则JVM无法停止。而守护线程则不会影响JVM的正常停止，即应用程序中有守护线程在运行也不影响JVM的正常停止。因此，守护线程通常用于执行一些重要性不是很高的任务，例如用于监视其他线程的运行情况。

创建一个Thread实例与创建其他类的实例不同的是，JVM会为一个Thread实例分配两个调用栈(Call Stack)所需的内存空间。这两个调用栈一个用于跟踪Java代码间的调用关系，另一个用于跟踪Java代码对本地代码(即Native代码，通常是C代码)的调用关系。

一个Thread实例通常对应两个线程，一个是JVM中的线程，另一个是与JVM中的线程相对应的依赖于JVM宿主机操作系统的本地（Native）线程。

在Linux下，可用perf命令来监视Java程序运行过程中的上下文切换，如：

```bash
perf stat -e cpu-clock,task-clock,cs,cache-references,cache-misses java ThreadCreationAndRun
```

参数e的值中的cs表示要监控程序的上下文切换的数量。

#### 内存可见性
CPU在执行代码的时候，为了减少变量访问的时间消耗，可能将代码中访问的变量的值缓存到该CPU的缓存区(如L1 Cache、L2 Cache等)。因此，相应代码再次访问某个变量时，相应的值可能是从CPU缓存区而不是主内存区中读取的。同样地，代码对这些被缓存过的变量的值的修改也可能仅是被写入CPU缓存区，而没有被写回主内存。由于每个CPU都有自己的缓存区，因此一个CPU缓存区中的内容对于其他CPU而言是不可见的。这就导致了在其他CPU上运行的其他线程可能无法“看到”该线程对某个变量值所做的变更。这就是所谓的内存可见性。

synchronized关键字保证了操作的原子性，本质是保证临界区(Critical Section)在任何一个时刻只有一个线程能够执行临界区中的代码。
synchronized关键字的另一个作用是保证了一个线程执行临界区中的代码时，所修改的变量值对于稍后执行该临界区中的代码的线程来说是可见的。

volatile 关键字也保证内存可见性。它实现的机制是当线程修改了一个volatile修饰的变量的值时，该值会被写入主内存，而不仅是当前线程所在的CPU缓存区，而其他CPU中存储的该变量的值也会因此而失效(从而得以更新为主内存中该变量的相应值)。
volatile 的另一个作用是它禁止了指令重排序(Re-order)。

#### 指令重排序
编译器和CPU为了提高指令的执行效率，可能会进行指令重排序，这使得代码的实际执行方式可能不是按代码顺序进行的。

#### synchronized 与 volatile 比较
synchronized 既能保证操作的原子性，又能保证内存可见性。而 volatile 仅能保证内存可见性。
但是，synchronized 会导致上下文切换，而 volatile 不会。

### 多线程编程常用术语
 - 任务(Task)
 - 并发(Concurrent): 表示多个任务在同一时间段内被执行。这些任务并不是顺序执行的，而往往是以交替的方式被执行
 - 并行(Parallel): 表示多个任务在同一时刻被执行
 - 显式锁(Explicit Lock): 指在Java代码中可以使用和控制的锁，即不是编译器和CPU内部使用的锁。包括synchronized关键字和java.util.concurrent.locks.Lock接口的所有实现类
 - 线程安全(Thread Safe): 一段操纵共享数据的代码，能够保证在同一时间内被多个线程执行而仍然保持其正确性的，就被称为线程安全的
 
 


