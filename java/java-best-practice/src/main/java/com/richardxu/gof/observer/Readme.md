### 观察者模式(Observer)，又称发布——订阅模式

#### 定义
定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

#### 结构
 - Subject: 目标对象，通常具有这些功能：
   - 一个目标可以被多个观察者观察
   - 目标提供对观察者注册和退订的维护
   - 当目标的状态发生变化时，目标负责通知所有注册的、有效的观察者
 - Observer: 定义观察者的接口，提供目标通知时对应的更新方法，这个更新方法进行相应的业务处理，这以在这个方法里回调目标对象，以获取目标对象的数据。
 - ConcreteSubject: 具体的目标对象，用来维护目标状态，当目标对象的状态发生改变时，通知所有注册的、有效的观察者，让观察者执行相应的处理。
 - ConcreteObserver: 观察者的具体实现对象。

#### 认识观察者模式
 1. 目标和观察者之间的关系：目标和观察者之间是典型的一对多关系；同样，一个观察者也可以观察多个目标。
 2. 单向依赖：只有观察者依赖于目标，而目标是不会依赖于观察者的。
 3. 触发通知的时机：一般情况下，是在完成了状态维护后触发，因为通知会传递数据，不能先通知后改数据，这很容易出问题，会导致观察者和目标对象的状态不一致。

#### 推模型和拉模型
 在观察者模式的实现中，又分为推模型和拉模型两种方式。
  - 推模型：目标对象主动向观察者推送目标的详细信息，推送的通常是目标对象的全部或部分数据，相当于是在广播通信。
  - 拉模型：目标对象在通知观察者时，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到目标对象中获取，相当于是观察者从目标对象中拉数据。
 两种实现模型的比较：
  - 推模型是假定目标对象知道观察者需要的数据；而拉模型是目标对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传给观察者，让观察者自己去按需取值。
  - 推模型可能会使得观察者对象难以复用，因为观察者定义的update方法是按需定义的，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能需要提供新的update方法，或者是干脆重新实现观察者。 

#### Java中的观察者模式
 在java.util包里有一个类Observable，它实现了大部分我们需要的目标的功能；还有一个接口Observer，其中定义了update方法，就是观察者的接口。

#### 观察者模式的优缺点
 优点:
  - 观察者模式实现了观察者和目标之间的抽象耦合
  - 观察者模式实现了动态联动
  - 观察者模式支持广播通信
  
 缺点:
  - 可能会引起无谓的操作
 
#### 观察者模式的本质
 观察者模式的本质：触发联动。
