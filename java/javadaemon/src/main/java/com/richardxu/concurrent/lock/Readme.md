### Java中的锁

#### Lock 接口
Lock接口及其相关实现类提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。
使用synchronized关键字将会隐式地获取锁，但是它将锁的获取和释放固化了，也就是先获取再释放。
`java
Lock lock = new ReentrantLock();
lock.lock();
try {
    
} finally {
    lock.unlock();
}
`
不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁释放。

Lock 接口提供的synchronized关键字不具备的特性
* 尝试非阻塞地获取锁 ( tryLock() )
* 能被中断地获取锁 ( lockInterruptibly() )
* 超时获取锁 ( tryLock(long time, TimeUnit unit) )

同步器AbstractQueuedSynchronizer。
Lock接口的实现基本都是通过聚合了一个同步器的子类来完成线程访问控制的。

#### 队列同步器(AbstractQueuedSynchronizer)
队列同步器是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量(state)表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。
同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。

同步器的设计是基于模板方法模式的。

#### 队列同步器的实现分析
##### 同步队列
同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理。当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点(Node)并将其加入同步队列，
同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。
同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点。

共享式获取与独占式获取最主要的区别在于同一时刻是否有多个线程同时获取到同步状态。通过调用同步器的acquireShared(int arg)方法可以共享式地获取同步状态。

#### 重入锁(ReentrantLock)
表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁还支持获取锁时的公平和非公平性选择。
synchronized隐式的支持重入锁。
ReentrantLock在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。

** 锁获取的公平性问题 **：如果在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之，是不公平的。公平的获取锁，也就是等待时间最长的线程最优先获取锁，也就是锁获取是顺序的。
ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。

公平锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其最大的吞吐量。


#### 读写锁
之前提到锁（如Mutex和ReentrantLock）基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻允许多个读线程访问。
但是在写线程访问时，所有读线程和其他写线程均被堵塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。
在读操作时获取读锁，在写操作时获取写锁。当写锁被获取时，后续（非当前写操作线程）的读写操作都会被阻塞，写锁释放之后，所有操作继续执行。

ReadWriteLock作为接口仅定义了获取读锁readLock()和写锁writeLock()两个方法，实现类有ReentrantReadWriteLock。


